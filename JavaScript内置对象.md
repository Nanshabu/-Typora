# JavaScript内置对象

## Array

### 描述

可以用一个变量存储多种**数据类型**的Array对象，Array不是关联数组，不能使用字符串作为索引访问数组元素，需要使用非负整数的下标访问数组中的元素。

和对象的某些特征很相似，例如：属性访问器一半相似，衍生出的使用 `.call()` 或者 `.apply()` 将数组方法赋予对象。

### 构造函数

TODO

### 方法

#### 陈旧的：

\1. `push()` - 在数组末尾添加一个或多个元素，并返回新的长度。

\2. `pop()` - 删除并返回数组的最后一个元素。

\3. `shift()` - 删除并返回数组的第一个元素。

\4. `unshift() `- 在数组的开头添加一个或多个元素，并返回新的长度。



\5. `splice()` - 通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。

\6. `slice()` - 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝。

\7. `concat()` - 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。

\8. `join() `- 将数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。



\9. `reverse() `- 颠倒数组中元素的顺序。

\10. `sort()` - 对数组的元素进行排序。

\11. `indexOf()` - 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。

\12. `lastIndexOf()` - 返回一个指定的元素在数组中最后出现的位置，如果不存在，则返回-1。



\13. `forEach()` - 对数组的每个元素执行一次提供的函数。

\14. `map()` - 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

\15. `filter()` - 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

\16. `reduce()` - 对数组中的所有元素执行一个由您提供的reducer函数（升序执行），将其结果汇总

#### 新颖的：

 `at()` - 通过下标访问数组元素，区别于直接用方括号访问，可以使用负数访问。

 `flat()` - 将数组扁平化，深度为1。通过传递一个数字参数修改深度。

 `flatMap()` - flat() 和 map() 的结合，先扁平（深度1）再遍历。

 `Array.from()` - 类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。例如字符串，map和set

 `Array.of()` - 创建一个数组，区别于直接使用 `Array()` 创建数组，括号内的内容是数组的实际数据。假如你想创建一个长度为7的数组应该使用 `Array(7)` 而不是 `Array.of(7)` ，因为后者会创建一个[7]的数组。

 `entries()` - 返回一个Array迭代器对象。

### Array.length

array.length 改变length属性会发生的情况，假如length小于数组最大的下标，会将length之后的元素清除。

数组的长度跟许多方法是挂钩的，例如 `entries()` 方法，会通过获取数组长度访问每个整数索引。可以简单的通过 `.call()` 方法验证：

```js
const arrayLike = {
  length: 3,
  0: "a",
  1: "b",
  2: "c",
};
for (const entry of Array.prototype.entries.call(arrayLike)) {
  console.log(entry);
}
// [ 0, 'a' ]
// [ 1, 'b' ]
// [ 2, 'c' ]
```

可以以此俩想到楼下的**通用数组方法**，**只**访问 `length` 属性和索引访问数组元素。

### 空槽和数组方法

可以使用 `Array(n)` 创建一个长度为n的空槽数组。

对于空槽而言，许多数组方法都会照顾一下。例如 `concat()` 方法就会将空槽省去。亦或是将空槽视为 `undefined` 例如你能想到的 `values()` 

### 数组遍历

`forEach()` 和 `for...in ` 两者在特殊情况下的不同效果

> for...in可能会迭代对象的原型链上的属性，而array.forEach不会迭代数组的原型链上的属性。此外，array.forEach可以使用break和continue语句来控制迭代。而for...in不能。

```js
const arr1 = [1, 2, 3];
arr1.name = "shit"


arr1.forEach((i) => {
  console.log(i);
}); // 1, 2, 3

for (const i in arr1) {
  console.log(arr1[i]);
}; // 1, 2, 3, shit
```



### 数组复制

深拷贝，浅拷贝  主要比较对象的引用是否一致。例如对象和数组这类数据类型可以想象成保存的是指向数据的地址，**浅拷贝的本质**是两个数组或者对象中的数据**指向了同一个目标**。而**深拷贝**则是两个**完全不同的数据指向**。

自带的一个浅拷贝 `slice()` 。

简单的完成一个深拷贝可以使用 `JSON` 提供的 `stringify` 和 `parse` 方法，通过转成 `JSON` 对象再转回数组的方式。

### Array[Symbol.species]

TODO

### 通用数组方法

指数组的不访问数组对象的任何内部数据，只访问 `length` 属性和索引访问数组元素。可以使用call方法在类数组对象上调用。

```js
const arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'
```

由此来看，数组和对象的相似性还是蛮大的，又或者是较简单的数据形式，提供的简单方法能够让开发者更便捷的对数据集进行操作。



## Set

set对象是es6引入的，以前似乎都是用对象来表示set。以键值对的方式存储数据，可以是基本数据类型也可以是引用对象。set中的元素（键）只会出现一次，这跟数组是很容易区分开的，也可以借此特性来为数组去重。

### 构造方法



### 静态属性



### 实例属性size



### 方法





















